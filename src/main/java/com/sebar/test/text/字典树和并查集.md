字典树 Trie树(多叉树) 单词查找树或键树
是一种树形结构，典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统
用于文本词频统计

优点：最大限度的减少无谓的字符串比较，查找的效率比哈希表高

1.字典树的数据结构

2.字典树的核心思想
    Trie树的核心思想是空间换时间
    利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的
3.字典树的基本性质
    1>节点本身不存完整单词
    2>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
    3>每个节点的所有子节点路径代表的字符不同

4.并查集 Disjoint set
makeSet(s):建立一个新的并查集，其中包含s个单元素集合
unionSet(x,y):把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并
find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们
各自的代表比较一下就可以了

class UnionFind{
    private int count=0;
    private int[] parent;
    public UnionFind(int n){
        count=n;
        parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
    }
    public int find(int p){
        while(p!=parent[p]){
            parent[p]=parent[parent[p]];
            p=parent[p];
        }
        return p;
    }
    public void union(int p,int q){
        int rootP=find(p);
        int rootQ=find(q);
        if(rootP==rootQ){
            return;
        }
        parent[rootP]=rootQ;
        count--;
    }
}

初级搜索
1.朴素搜索
2.优化方式：不重复（fibonacci）、剪枝(生成括号问题)
    剪枝就是整个状态树，这一个分治是没有必要的时候，我们就把它剪掉，不进行搜索
    这种没有必要性是来自一个是重复，也有可能是每次要找最优解
3.搜索方向:
    DFS:depth first search 深度优先搜索
    BFS:breath First search 广度优先搜索
    
    双向搜索、启发式搜索(优先队列)
    
    

